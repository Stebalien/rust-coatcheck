var searchIndex = {};
searchIndex['coatcheck'] = {"items":[[0,"","coatcheck","# CoatCheck\n \nCoatCheck is a library for storing values and referencing them by \"handles\"\n(`Tickets`). This library is primarily designed for when one needs to be able\nto \"register\" an object with a system and refer to it after registration but\none doesn't need to actually access the object.\n \n## Explanation by example\n \nFor example, let's say you were implementing a callback system:\n \n```rust\nstruct System {\n    callbacks: Vec<Box<FnMut() + 'static>>,\n}\n \nimpl System {\n    fn add_callback<C>(&mut self, cb: C) where C: FnMut() + 'static {\n        self.callbacks.push(Box::new(cb));\n    }\n    fn fire(&mut self) {\n        for cb in self.callbacks.iter_mut() {\n            (cb)();\n        }\n    }\n}\n```\n \nThis system works but doesn't allow unregistering. If you wanted to allow\nunregistering individual callbacks, you could do something like:\n \n```rust\nuse std::collections::HashMap;"],[1,"Ticket","","A `Ticket` is an opaque data structure that can be used to claim the associated value."],[1,"Tickets","",""],[1,"GenericIter","",""],[1,"CoatCheck","",""],[4,"IntoIter","",""],[4,"Iter","",""],[4,"IterMut","",""],[10,"fmt","","",0],[4,"Item","",""],[10,"next","","",1],[10,"size_hint","","",1],[10,"next_back","","",1],[10,"indexable","","",1],[10,"idx","","",1],[10,"len","","",2],[4,"Item","",""],[10,"next","","",2],[10,"size_hint","","",2],[10,"next_back","","",2],[10,"new","","Constructs a new, empty `CoatCheck<T>`.",3],[10,"with_capacity","","Constructs a new, empty `CoatCheck<T>` with the specified capacity.",3],[10,"capacity","","Returns the number of elements the coat check can hold without reallocating.",3],[10,"len","","The number of checked items.",3],[10,"reserve","","Reserves capacity for at least `additional` more elements to be checked into the given\n`CoatCheck<T>`. The collection may reserve more space to avoid frequent reallocations.",3],[10,"reserve_exact","","Reserves the minimum capacity for exactly `additional` more elements to be check into the\ngiven `CoatCheck<T>`. Does nothing if the capacity is already sufficient.",3],[10,"check","","Check a value in and get a `Ticket `in exchange.",3],[10,"check_all","","Check all the items in an iterator and get tickets back.",3],[10,"iter","","Iterate over the items in this `CoatCheck<V>`.",3],[10,"iter_mut","","Mutably iterate over the items in this `CoatCheck<V>`.",3],[10,"into_iter","","Creates a consuming iterator, that is, one that moves each value out of the coat check (from\nstart to end). The coat check cannot be used after calling this.",3],[10,"contains_ticket","","Check if a ticket belongs to this `CoatCheck<V>`.",3],[10,"is_empty","","Check if this `CoatCheck<V>` is empty.",3],[10,"claim","","Claim an item.",3],[10,"get","","Get a reference to the value matching this ticket.",3],[10,"get_mut","","Get a mutable reference to the value matching this ticket.",3],[10,"fmt","","",3],[4,"Output","",""],[10,"index","","",3],[4,"Output","",""],[10,"index_mut","","",3],[10,"default","","",3]],"paths":[[1,"Ticket"],[1,"Tickets"],[1,"GenericIter"],[1,"CoatCheck"]]};
initSearch(searchIndex);
